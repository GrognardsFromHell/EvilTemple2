<?xml version="1.0" encoding="utf-8"?>
<material xmlns="http://hartte.de/eviltemple/material.xsd">

  <pass>
    <shader>
      <vertexShader>
        <code>
          <![CDATA[
#version 120

uniform mat4 worldViewProjectionMatrix;
const vec4 invertedLightDirection = vec4(0.447, 0.89, 0, 0);

attribute vec4 vertexPosition;
attribute vec2 vertexTexCoord;

{{LIGHTING_ON}}
uniform mat4 worldViewMatrix;
attribute vec4 vertexNormal;
varying vec4 normal;
varying vec4 light;
{{/LIGHTING_ON}}

varying vec2 texCoord;

void main() {
{{LIGHTING_ON}}
        light = worldViewMatrix * invertedLightDirection;
        normal = normalize(worldViewMatrix * vertexNormal);
{{/LIGHTING_ON}}

        gl_Position = worldViewProjectionMatrix * vertexPosition;
        texCoord = vertexTexCoord; // Pass through texture coordinates
}
]]>
        </code>
      </vertexShader>

      <fragmentShader>
        <code>
        <![CDATA[
#version 120

{{LIGHTING_ON}}
varying vec4 normal;
varying vec4 light;
{{/LIGHTING_ON}}

const vec4 globalAmbient = vec4(0.1, 0.1, 0.1, 1);
const vec4 diffuseLightColor = vec4(0.9, 0.9, 0.9, 1);
const vec4 materialDiffuse = vec4({{MATERIAL_DIFFUSE}});

varying vec2 texCoord;

{{SAMPLERS}}

void main(void)
{
{{LIGHTING_ON}}
   float cosTheta = abs(dot(normal,light));
   vec4 Idiff = materialDiffuse * diffuseLightColor * cosTheta + globalAmbient;
   Idiff = clamp(Idiff, 0.0, 1.0);
{{/LIGHTING_ON}}

   {{PIXEL_TERM}}
}
]]>
        </code>
      </fragmentShader>

      <attribute name="vertexPosition" buffer="positions" />
      {{LIGHTING_ON}}
      <attribute name="vertexNormal" buffer="normals" />
      {{/LIGHTING_ON}}
      <attribute name="vertexTexCoord" buffer="texCoords" components="2" />
      <uniform name="worldViewProjectionMatrix" semantic="WorldViewProjection" />
      {{LIGHTING_ON}}
      <uniform name="worldViewMatrix" semantic="WorldView" />
      {{/LIGHTING_ON}}
      {{SAMPLER_UNIFORMS}}
    </shader>

    {{TEXTURES}}

    <cullFace>{{CULL_FACE}}</cullFace>
    <blend>{{BLEND}}</blend>
    <blendFunc src="{{BLEND_SRC}}" dest="{{BLEND_DEST}}" />
    <depthWrite>{{DEPTH_WRITE}}</depthWrite>
    <depthTest>{{DEPTH_TEST}}</depthTest>
  </pass>

{{SHADOW_ON}}
<!--
    Shadow pass
-->
  <pass>
    <shader>
      <vertexShader>
        <code>
          <![CDATA[
#version 120

uniform mat4 viewProjectionMatrix;
uniform mat4 worldMatrix;
const vec4 invertedLightDirection = vec4(0.447, 0.89, 0, 0);

attribute vec4 vertexPosition;

void main() {
  vec4 v = worldMatrix * vertexPosition;

  float lambda = v.y / invertedLightDirection.y; // y must be non-zero
  v.y = 0;
  v.x -= invertedLightDirection.x * lambda;
  v.z -= invertedLightDirection.z * lambda;

  gl_Position = viewProjectionMatrix * v;
}
]]>
        </code>
      </vertexShader>

      <fragmentShader>
        <code>
          <![CDATA[
#version 120

void main(void)
{
   gl_FragColor = vec4(0, 0, 0, 0.75);
}
]]>
        </code>
      </fragmentShader>

      <attribute name="vertexPosition" buffer="positions" />
      <uniform name="viewProjectionMatrix" semantic="ViewProjection" />
      <uniform name="worldMatrix" semantic="World" />
    </shader>

    <depthWrite>false</depthWrite>
  </pass>
{{/SHADOW_ON}}

</material>
